//! Filter expression parser and evaluator.
//!
//! Parses the pandas-eval query strings generated by the Python Filter DSL
//! into an AST, then evaluates against Polars DataFrames.
//!
//! Supported patterns (all generated by schema.py):
//!   "(type == 'put') & (ask > 0)"
//!   "(underlying == 'SPX') & (dte >= 60) & (dte <= 120)"
//!   "(strike >= underlying_last * 1.02)"
//!   "dte <= 30"

use polars::prelude::*;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum FilterError {
    #[error("parse error: {0}")]
    Parse(String),
    #[error("polars error: {0}")]
    Polars(#[from] PolarsError),
}

/// A parsed value literal.
#[derive(Debug, Clone, PartialEq)]
pub enum Value {
    Int(i64),
    Float(f64),
    Str(String),
    Column(String),
}

/// Comparison operator.
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum CmpOp {
    Eq,
    Ne,
    Lt,
    Le,
    Gt,
    Ge,
}

/// Arithmetic operator for column expressions.
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ArithOp {
    Add,
    Sub,
    Mul,
    Div,
}

/// Compiled filter expression AST.
#[derive(Debug, Clone, PartialEq)]
pub enum FilterExpr {
    Cmp(String, CmpOp, Value),
    /// column <arith_op> value <cmp_op> value
    /// e.g. strike >= underlying_last * 1.02
    ColArith(String, ArithOp, Value, CmpOp, Value),
    And(Box<FilterExpr>, Box<FilterExpr>),
    Or(Box<FilterExpr>, Box<FilterExpr>),
    Not(Box<FilterExpr>),
}

/// Tokenizer for filter expressions.
#[derive(Debug, Clone, PartialEq)]
enum Token {
    Ident(String),
    StrLit(String),
    IntLit(i64),
    FloatLit(f64),
    Eq,    // ==
    Ne,    // !=
    Lt,    // <
    Le,    // <=
    Gt,    // >
    Ge,    // >=
    And,   // &
    Or,    // |
    Not,   // !
    LParen,
    RParen,
    Plus,
    Minus,
    Star,
    Slash,
}

fn tokenize(input: &str) -> Result<Vec<Token>, FilterError> {
    let mut tokens = Vec::new();
    let chars: Vec<char> = input.chars().collect();
    let mut i = 0;

    while i < chars.len() {
        match chars[i] {
            ' ' | '\t' | '\n' => i += 1,
            '(' => { tokens.push(Token::LParen); i += 1; }
            ')' => { tokens.push(Token::RParen); i += 1; }
            '&' => { tokens.push(Token::And); i += 1; }
            '|' => { tokens.push(Token::Or); i += 1; }
            '+' => { tokens.push(Token::Plus); i += 1; }
            '-' => { tokens.push(Token::Minus); i += 1; }
            '*' => { tokens.push(Token::Star); i += 1; }
            '/' => { tokens.push(Token::Slash); i += 1; }
            '!' => {
                if i + 1 < chars.len() && chars[i + 1] == '=' {
                    tokens.push(Token::Ne);
                    i += 2;
                } else {
                    tokens.push(Token::Not);
                    i += 1;
                }
            }
            '=' => {
                if i + 1 < chars.len() && chars[i + 1] == '=' {
                    tokens.push(Token::Eq);
                    i += 2;
                } else {
                    return Err(FilterError::Parse(format!("unexpected '=' at {i}")));
                }
            }
            '<' => {
                if i + 1 < chars.len() && chars[i + 1] == '=' {
                    tokens.push(Token::Le);
                    i += 2;
                } else {
                    tokens.push(Token::Lt);
                    i += 1;
                }
            }
            '>' => {
                if i + 1 < chars.len() && chars[i + 1] == '=' {
                    tokens.push(Token::Ge);
                    i += 2;
                } else {
                    tokens.push(Token::Gt);
                    i += 1;
                }
            }
            '\'' | '"' => {
                let quote = chars[i];
                i += 1;
                let start = i;
                while i < chars.len() && chars[i] != quote {
                    i += 1;
                }
                let s: String = chars[start..i].iter().collect();
                tokens.push(Token::StrLit(s));
                i += 1; // skip closing quote
            }
            c if c.is_ascii_digit() || c == '.' => {
                let start = i;
                let mut has_dot = c == '.';
                let mut has_exp = false;
                i += 1;
                while i < chars.len() && (chars[i].is_ascii_digit() || chars[i] == '.') {
                    if chars[i] == '.' { has_dot = true; }
                    i += 1;
                }
                // Scientific notation: e/E followed by optional +/- and digits
                if i < chars.len() && (chars[i] == 'e' || chars[i] == 'E') {
                    has_exp = true;
                    i += 1;
                    if i < chars.len() && (chars[i] == '+' || chars[i] == '-') {
                        i += 1;
                    }
                    while i < chars.len() && chars[i].is_ascii_digit() {
                        i += 1;
                    }
                }
                let num_str: String = chars[start..i].iter().collect();
                if has_dot || has_exp {
                    tokens.push(Token::FloatLit(
                        num_str.parse().map_err(|e| FilterError::Parse(format!("{e}")))?,
                    ));
                } else {
                    tokens.push(Token::IntLit(
                        num_str.parse().map_err(|e| FilterError::Parse(format!("{e}")))?,
                    ));
                }
            }
            c if c.is_ascii_alphabetic() || c == '_' => {
                let start = i;
                i += 1;
                while i < chars.len() && (chars[i].is_ascii_alphanumeric() || chars[i] == '_') {
                    i += 1;
                }
                let ident: String = chars[start..i].iter().collect();
                tokens.push(Token::Ident(ident));
            }
            c => return Err(FilterError::Parse(format!("unexpected char '{c}' at {i}"))),
        }
    }

    Ok(tokens)
}

/// Recursive descent parser.
struct Parser {
    tokens: Vec<Token>,
    pos: usize,
}

impl Parser {
    fn new(tokens: Vec<Token>) -> Self {
        Self { tokens, pos: 0 }
    }

    fn peek(&self) -> Option<&Token> {
        self.tokens.get(self.pos)
    }

    fn advance(&mut self) -> Option<Token> {
        let tok = self.tokens.get(self.pos)?.clone();
        self.pos += 1;
        Some(tok)
    }

    fn expect(&mut self, expected: &Token) -> Result<(), FilterError> {
        let tok = self.advance().ok_or_else(|| FilterError::Parse("unexpected end".into()))?;
        if &tok != expected {
            return Err(FilterError::Parse(format!("expected {expected:?}, got {tok:?}")));
        }
        Ok(())
    }

    /// expr = or_expr
    fn parse_expr(&mut self) -> Result<FilterExpr, FilterError> {
        self.parse_or()
    }

    /// or_expr = and_expr ( '|' and_expr )*
    fn parse_or(&mut self) -> Result<FilterExpr, FilterError> {
        let mut left = self.parse_and()?;
        while matches!(self.peek(), Some(Token::Or)) {
            self.advance();
            let right = self.parse_and()?;
            left = FilterExpr::Or(Box::new(left), Box::new(right));
        }
        Ok(left)
    }

    /// and_expr = unary ( '&' unary )*
    fn parse_and(&mut self) -> Result<FilterExpr, FilterError> {
        let mut left = self.parse_unary()?;
        while matches!(self.peek(), Some(Token::And)) {
            self.advance();
            let right = self.parse_unary()?;
            left = FilterExpr::And(Box::new(left), Box::new(right));
        }
        Ok(left)
    }

    /// unary = '!' unary | primary
    fn parse_unary(&mut self) -> Result<FilterExpr, FilterError> {
        if matches!(self.peek(), Some(Token::Not)) {
            self.advance();
            let inner = self.parse_unary()?;
            return Ok(FilterExpr::Not(Box::new(inner)));
        }
        self.parse_primary()
    }

    /// primary = '(' expr ')' | comparison
    fn parse_primary(&mut self) -> Result<FilterExpr, FilterError> {
        if matches!(self.peek(), Some(Token::LParen)) {
            self.advance();
            let expr = self.parse_expr()?;
            self.expect(&Token::RParen)?;
            return Ok(expr);
        }
        self.parse_comparison()
    }

    /// comparison = value cmp_op value
    /// value can be: ident, ident arith_op literal, literal
    fn parse_comparison(&mut self) -> Result<FilterExpr, FilterError> {
        let left = self.parse_value_expr()?;
        let cmp = self.parse_cmp_op()?;
        let right = self.parse_value_expr()?;

        match (left, right) {
            // column cmp literal/column
            (ValueExpr::Column(name), ValueExpr::Literal(val)) => {
                Ok(FilterExpr::Cmp(name, cmp, val))
            }
            (ValueExpr::Column(name), ValueExpr::Column(rhs)) => {
                Ok(FilterExpr::Cmp(name, cmp, Value::Column(rhs)))
            }
            // column_arith cmp value
            (ValueExpr::Arith(name, op, operand), rhs) => {
                Ok(FilterExpr::ColArith(name, op, operand, cmp, self.value_expr_to_value(rhs)?))
            }
            // column cmp column_arith  →  flip to ColArith form
            // e.g. strike >= underlying_last * 1.02
            //    → ColArith("underlying_last", Mul, 1.02, Le, Column("strike"))
            (ValueExpr::Column(name), ValueExpr::Arith(rhs_col, op, operand)) => {
                Ok(FilterExpr::ColArith(rhs_col, op, operand, flip_cmp(cmp), Value::Column(name)))
            }
            // literal cmp column → flip
            (ValueExpr::Literal(val), ValueExpr::Column(name)) => {
                Ok(FilterExpr::Cmp(name, flip_cmp(cmp), val))
            }
            _ => Err(FilterError::Parse("unsupported comparison form".into())),
        }
    }

    fn parse_value_expr(&mut self) -> Result<ValueExpr, FilterError> {
        let tok = self.advance().ok_or_else(|| FilterError::Parse("unexpected end".into()))?;
        match tok {
            Token::Ident(name) => {
                // Check for arithmetic: ident * 1.02
                if let Some(arith) = self.try_parse_arith() {
                    return Ok(ValueExpr::Arith(name, arith.0, arith.1));
                }
                Ok(ValueExpr::Column(name))
            }
            Token::IntLit(n) => {
                // Check for arithmetic: 1.02 * ident (reversed)
                Ok(ValueExpr::Literal(Value::Int(n)))
            }
            Token::FloatLit(f) => Ok(ValueExpr::Literal(Value::Float(f))),
            Token::StrLit(s) => Ok(ValueExpr::Literal(Value::Str(s))),
            t => Err(FilterError::Parse(format!("unexpected token in value: {t:?}"))),
        }
    }

    fn try_parse_arith(&mut self) -> Option<(ArithOp, Value)> {
        let op = match self.peek()? {
            Token::Plus => ArithOp::Add,
            Token::Minus => ArithOp::Sub,
            Token::Star => ArithOp::Mul,
            Token::Slash => ArithOp::Div,
            _ => return None,
        };
        self.advance();
        let val = match self.advance()? {
            Token::IntLit(n) => Value::Int(n),
            Token::FloatLit(f) => Value::Float(f),
            Token::Ident(s) => Value::Column(s),
            _ => return None,
        };
        Some((op, val))
    }

    fn parse_cmp_op(&mut self) -> Result<CmpOp, FilterError> {
        match self.advance() {
            Some(Token::Eq) => Ok(CmpOp::Eq),
            Some(Token::Ne) => Ok(CmpOp::Ne),
            Some(Token::Lt) => Ok(CmpOp::Lt),
            Some(Token::Le) => Ok(CmpOp::Le),
            Some(Token::Gt) => Ok(CmpOp::Gt),
            Some(Token::Ge) => Ok(CmpOp::Ge),
            t => Err(FilterError::Parse(format!("expected comparison op, got {t:?}"))),
        }
    }

    fn value_expr_to_value(&self, ve: ValueExpr) -> Result<Value, FilterError> {
        match ve {
            ValueExpr::Column(name) => Ok(Value::Column(name)),
            ValueExpr::Literal(val) => Ok(val),
            ValueExpr::Arith(..) => Err(FilterError::Parse(
                "arithmetic expressions only supported on left side".into(),
            )),
        }
    }
}

#[derive(Debug)]
enum ValueExpr {
    Column(String),
    Literal(Value),
    Arith(String, ArithOp, Value),
}

fn flip_cmp(op: CmpOp) -> CmpOp {
    match op {
        CmpOp::Lt => CmpOp::Gt,
        CmpOp::Le => CmpOp::Ge,
        CmpOp::Gt => CmpOp::Lt,
        CmpOp::Ge => CmpOp::Le,
        other => other,
    }
}

/// Parse a query string into a FilterExpr AST.
pub fn parse(query: &str) -> Result<FilterExpr, FilterError> {
    let tokens = tokenize(query)?;
    let mut parser = Parser::new(tokens);
    let expr = parser.parse_expr()?;
    if parser.pos != parser.tokens.len() {
        return Err(FilterError::Parse(format!(
            "unexpected tokens after position {}",
            parser.pos
        )));
    }
    Ok(expr)
}

/// Convert a FilterExpr to a Polars Expr for lazy evaluation.
pub fn to_polars_expr(filter: &FilterExpr) -> Expr {
    match filter {
        FilterExpr::Cmp(column, op, value) => {
            let c = col(column.as_str());
            let v = value_to_lit(value);
            apply_cmp(c, *op, v)
        }
        FilterExpr::ColArith(column, arith_op, arith_val, cmp_op, cmp_val) => {
            let c = col(column.as_str());
            let av = value_to_lit(arith_val);
            let arith_expr = match arith_op {
                ArithOp::Add => c + av,
                ArithOp::Sub => c - av,
                ArithOp::Mul => c * av,
                ArithOp::Div => c / av,
            };
            let cv = value_to_lit(cmp_val);
            apply_cmp(arith_expr, *cmp_op, cv)
        }
        FilterExpr::And(left, right) => {
            to_polars_expr(left).and(to_polars_expr(right))
        }
        FilterExpr::Or(left, right) => {
            to_polars_expr(left).or(to_polars_expr(right))
        }
        FilterExpr::Not(inner) => {
            to_polars_expr(inner).not()
        }
    }
}

fn value_to_lit(value: &Value) -> Expr {
    match value {
        // Always use f64 for numeric literals to avoid Int128 issues in polars 0.48
        Value::Int(n) => lit(*n as f64),
        Value::Float(f) => lit(*f),
        Value::Str(s) => lit(s.as_str()),
        Value::Column(name) => col(name.as_str()),
    }
}

fn apply_cmp(left: Expr, op: CmpOp, right: Expr) -> Expr {
    match op {
        CmpOp::Eq => left.eq(right),
        CmpOp::Ne => left.neq(right),
        CmpOp::Lt => left.lt(right),
        CmpOp::Le => left.lt_eq(right),
        CmpOp::Gt => left.gt(right),
        CmpOp::Ge => left.gt_eq(right),
    }
}

/// A compiled filter: parsed once, evaluated many times.
pub struct CompiledFilter {
    pub expr: FilterExpr,
    pub polars_expr: Expr,
}

impl CompiledFilter {
    pub fn new(query: &str) -> Result<Self, FilterError> {
        let expr = parse(query)?;
        let polars_expr = to_polars_expr(&expr);
        Ok(Self { expr, polars_expr })
    }

    pub fn apply(&self, df: &DataFrame) -> PolarsResult<DataFrame> {
        let mask = df
            .clone()
            .lazy()
            .select([self.polars_expr.clone().alias("_mask")])
            .collect()?;
        let bool_mask = mask.column("_mask")?.bool()?.clone();
        df.filter(&bool_mask)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_simple_eq() {
        let expr = parse("type == 'put'").unwrap();
        assert_eq!(
            expr,
            FilterExpr::Cmp("type".into(), CmpOp::Eq, Value::Str("put".into()))
        );
    }

    #[test]
    fn parse_simple_gte() {
        let expr = parse("dte >= 60").unwrap();
        assert_eq!(
            expr,
            FilterExpr::Cmp("dte".into(), CmpOp::Ge, Value::Int(60))
        );
    }

    #[test]
    fn parse_and() {
        let expr = parse("(type == 'put') & (ask > 0)").unwrap();
        match expr {
            FilterExpr::And(left, right) => {
                assert_eq!(
                    *left,
                    FilterExpr::Cmp("type".into(), CmpOp::Eq, Value::Str("put".into()))
                );
                assert_eq!(
                    *right,
                    FilterExpr::Cmp("ask".into(), CmpOp::Gt, Value::Int(0))
                );
            }
            _ => panic!("expected And"),
        }
    }

    #[test]
    fn parse_col_arith() {
        // "strike >= underlying_last * 1.02" flips to:
        // ColArith("underlying_last", Mul, 1.02, Le, Column("strike"))
        let expr = parse("strike >= underlying_last * 1.02").unwrap();
        match expr {
            FilterExpr::ColArith(ref col, ArithOp::Mul, Value::Float(f), CmpOp::Le, Value::Column(ref rhs)) => {
                assert_eq!(col, "underlying_last");
                assert!((f - 1.02).abs() < 1e-10);
                assert_eq!(rhs, "strike");
            }
            _ => panic!("expected ColArith, got {expr:?}"),
        }
    }

    #[test]
    fn parse_chained_and() {
        let expr = parse("(underlying == 'SPX') & (dte >= 60) & (dte <= 120)").unwrap();
        // Should be And(And(eq, gte), lte)
        match expr {
            FilterExpr::And(_, _) => {} // OK
            _ => panic!("expected chained And"),
        }
    }

    #[test]
    fn compiled_filter_apply() {
        let df = DataFrame::new(vec![
            Column::new("type".into(), &["call", "put", "put"]),
            Column::new("ask".into(), &[1.0f64, 2.0, 0.0]),
        ])
        .unwrap();

        let f = CompiledFilter::new("(type == 'put') & (ask > 0)").unwrap();
        let result = f.apply(&df).unwrap();
        assert_eq!(result.height(), 1);
    }

    #[test]
    fn compiled_filter_dte_range() {
        let df = DataFrame::new(vec![
            Column::new("underlying".into(), &["SPX", "SPX", "AAPL", "SPX"]),
            Column::new("dte".into(), &[30i32, 90, 90, 150]),
        ])
        .unwrap();

        let f = CompiledFilter::new("(underlying == 'SPX') & (dte >= 60) & (dte <= 120)").unwrap();
        let result = f.apply(&df).unwrap();
        assert_eq!(result.height(), 1); // Only SPX with dte=90
    }

    #[test]
    fn parse_scientific_notation() {
        let expr = parse("ask > 1e-5").unwrap();
        match expr {
            FilterExpr::Cmp(col, CmpOp::Gt, Value::Float(f)) => {
                assert_eq!(col, "ask");
                assert!((f - 1e-5).abs() < 1e-15);
            }
            _ => panic!("expected Cmp with float, got {expr:?}"),
        }
    }

    #[test]
    fn parse_scientific_notation_positive_exp() {
        let expr = parse("strike >= 1.5E3").unwrap();
        match expr {
            FilterExpr::Cmp(col, CmpOp::Ge, Value::Float(f)) => {
                assert_eq!(col, "strike");
                assert!((f - 1500.0).abs() < 1e-10);
            }
            _ => panic!("expected Cmp with float, got {expr:?}"),
        }
    }

    #[test]
    fn parse_scientific_notation_no_sign() {
        let expr = parse("delta >= 1e2").unwrap();
        match expr {
            FilterExpr::Cmp(_, CmpOp::Ge, Value::Float(f)) => {
                assert!((f - 100.0).abs() < 1e-10);
            }
            _ => panic!("expected float, got {expr:?}"),
        }
    }

    #[test]
    fn compiled_filter_scientific_notation() {
        let df = DataFrame::new(vec![
            Column::new("ask".into(), &[0.0f64, 0.00001, 0.1, 5.0]),
        ]).unwrap();

        let f = CompiledFilter::new("ask > 1e-3").unwrap();
        let result = f.apply(&df).unwrap();
        assert_eq!(result.height(), 2); // 0.1 and 5.0
    }
}
